---
layout: learning-topic
title: Lightning Web Components (LWC) - Mastering Salesforce Development
permalink: /lwc-essentials/
sidebar_title: LWC Essentials Topics
intro_text: Dive into the world of Lightning Web Components (LWC), Salesforce's modern framework for building high-performance UI. This module covers LWC fundamentals, component structure, data flow, event communication, and best practices.
topics:
  - id: introduction
    number: 1
    title: Introduction to LWC
  - id: lwc-basics
    number: 2
    title: LWC Core Concepts
  - id: component-structure
    number: 3
    title: LWC Component Structure
  - id: data-flow-decorators
    number: 4
    title: Data Flow & Decorators (@api, @track, @wire)
  - id: event-communication
    number: 5
    title: Event Communication
  - id: lifecycle-hooks
    number: 6
    title: LWC Lifecycle Hooks
  - id: working-with-apex
    number: 7
    title: Working with Apex in LWC
  - id: best-practices
    number: 8
    title: LWC Best Practices
  - id: conclusion
    number: 9
    title: Conclusion & Next Steps
---

<style>
    /* General body styling for better readability */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        background-color: #f8f9fa;
        margin: 0;
        padding: 20px;
    }

    .topic-content-section {
        background-color: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        margin-bottom: 30px;
        padding: 30px;
    }

    h1, h2, h3 {
        color: #0056b3;
        margin-top: 0;
        margin-bottom: 20px;
    }

    h2 {
        font-size: 2.2em;
        border-bottom: 2px solid #e9ecef;
        padding-bottom: 15px;
    }

    h3 {
        font-size: 1.6em;
        color: #007bff;
        margin-top: 25px;
        margin-bottom: 15px;
    }

    p {
        margin-bottom: 15px;
        color: #555;
    }

    ul {
        list-style-type: disc;
        margin-left: 25px;
        margin-bottom: 15px;
    }

    li {
        margin-bottom: 8px;
        color: #444;
    }

    strong {
        color: #0056b3;
    }

    /* Styling for pre and code blocks */
    pre {
        background-color: #272c34; /* Darker background for code */
        color: #f8f8f2; /* Light text for code */
        padding: 15px 20px;
        border-radius: 6px;
        overflow-x: auto;
        font-family: 'Fira Code', 'Cascadia Code', 'Consolas', 'Monaco', monospace;
        font-size: 0.95em;
        line-height: 1.4;
        margin-top: 15px;
        margin-bottom: 25px;
        box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    code {
        font-family: 'Fira Code', 'Cascadia Code', 'Consolas', 'Monaco', monospace;
        background-color: #e0e0e0; /* Light background for inline code */
        color: #c7254e; /* Darker text for inline code */
        padding: 2px 5px;
        border-radius: 4px;
        font-size: 0.9em;
        white-space: nowrap;
    }

    pre code {
        background-color: transparent;
        color: inherit;
        padding: 0;
        border-radius: 0;
        white-space: pre;
    }

    /* Specific syntax highlighting like effects (simulated) */
    .language-html .tag, .language-xml .tag { color: #5bc0de; } /* Blue for tags */
    .language-html .attr, .language-xml .attr { color: #f0ad4e; } /* Orange for attributes */
    .language-html .string, .language-xml .string { color: #5cb85c; } /* Green for strings */

    .language-javascript .keyword, .language-apex .keyword { color: #d9534f; } /* Red for keywords */
    .language-javascript .function, .language-apex .function { color: #428bca; } /* Light blue for functions */
    .language-javascript .comment, .language-apex .comment { color: #888; font-style: italic; }
    .language-javascript .decorator { color: #d9534f; } /* Red for decorators */
    .language-javascript .string, .language-apex .string { color: #5cb85c; } /* Green for strings */

    .language-css .property { color: #f0ad4e; } /* Orange for CSS properties */
    .language-css .value { color: #5cb85c; } /* Green for CSS values */
    .language-css .selector { color: #428bca; } /* Light blue for CSS selectors */

    .language-plaintext { color: #f8f8f2; } /* Plain text in pre tag */
</style>

<div id="content-introduction" class="topic-content-section">
    <h2>1. Introduction to LWC</h2>
    <p>Lightning Web Components (LWC) represents Salesforce's modern approach to building user interfaces on the Lightning Platform. Introduced in Spring '19, LWC is a client-side JavaScript framework built on web standards, offering superior performance, a familiar development experience for web developers, and seamless integration with the Salesforce ecosystem.</p>
    <h3>What is LWC?</h3>
    <p>LWC is a lightweight, performant framework for building single-page applications and reusable UI components. It leverages modern web standards (<code>ECMAScript 7+</code>, <code>Web Components</code>, <code>Shadow DOM</code>) and provides a thin layer of Salesforce-specific services on top. This makes LWC development feel more like standard web development, attracting a broader range of developers to the Salesforce platform.</p>
    <h3>Why LWC?</h3>
    <ul>
        <li><strong>Performance:</strong> Built on web standards, LWC is significantly faster than its predecessor, Aura Components, due to less framework overhead and native browser support.</li>
        <li><strong>Modern Web Standards:</strong> Familiarity for web developers, easier to learn, and aligns with industry best practices.</li>
        <li><strong>Reusability:</strong> Components are designed to be modular and reusable across different parts of your Salesforce org or even in Experience Cloud sites.</li>
        <li><strong>Security:</strong> Leverages <code>Shadow DOM</code> for encapsulation, protecting component internals from external interference.</li>
        <li><strong>Developer Productivity:</strong> Modern tooling, clear component lifecycle, and a streamlined development model.</li>
        <li><strong>Coexistence with Aura:</strong> LWC and Aura components can coexist and even communicate within the same Lightning page, allowing for gradual migration and mixed applications.</li>
    </ul>
    <p>LWC is the recommended framework for building new UI components on the Salesforce platform. While Aura components are still supported, LWC offers the most benefits for future development.</p>
</div>

<div id="content-lwc-basics" class="topic-content-section">
    <h2>2. LWC Core Concepts</h2>
    <p>At its heart, an LWC is a custom HTML element with its own JavaScript, HTML template, and CSS. These three files work together to define the component's behavior, structure, and styling.</p>
    <h3>a. Component-Based Architecture:</h3>
    <p>LWC promotes a component-based architecture, where UIs are broken down into small, independent, and reusable building blocks. Each component manages its own state and renders its own UI, making development modular and maintainable.</p>
    <h3>b. HTML Template (<code>.html</code>):</h3>
    <p>This file defines the component's UI structure using standard HTML with some special LWC directives. It uses a <code>&lt;template&gt;</code> tag as the root.</p>
    <pre><code class="language-html">&lt;template&gt;
    &lt;div class="container"&gt;
        &lt;h1&gt;Hello, {greeting}!&lt;/h1&gt;
        &lt;button onclick={handleClick}&gt;Change Greeting&lt;/button&gt;
    &lt;/div&gt;
&lt;/template&gt;
</code></pre>
    <ul>
        <li><code>{property}</code>: Binds data from the JavaScript class to the template.</li>
        <li><code>onclick={methodName}</code>: Binds an event to a JavaScript method.</li>
        <li>Conditional Rendering (<code>lwc:if</code>, <code>lwc:elseif</code>, <code>lwc:else</code>): Controls whether elements are rendered.</li>
        <li>Iteration (<code>for:each</code>, <code>for:item</code>, <code>for:index</code>): Renders a list of items.</li>
    </ul>

    <h3>c. JavaScript Class (<code>.js</code>):</h3>
    <p>This file contains the component's logic, data, and event handlers. It's an <code>ES6</code> module that imports functionalities from the <code>lwc</code> module.</p>
    <pre><code class="language-javascript">// helloWorld.js
import { LightningElement, api, track } from 'lwc';

export default class HelloWorld extends LightningElement {
    @api greeting = 'World'; // Public property
    @track counter = 0; // Reactive private property

    connectedCallback() {
        console.log('Component is connected to the DOM!');
    }

    handleClick() {
        this.counter++;
        this.greeting = 'Salesforce Developer ' + this.counter;
    }
}
</code></pre>
    <ul>
        <li><code>import { LightningElement }s from 'lwc';</code>: Imports the base class for LWC.</li>
        <li><code>export default class ... extends LightningElement</code>: Defines the component's JavaScript class.</li>
        <li>Decorators (<code>@api</code>, <code>@track</code>, <code>@wire</code>): Special annotations that add reactive or public capabilities to properties and functions (covered in detail later).</li>
    </ul>

    <h3>d. CSS (<code>.css</code>):</h3>
    <p>This file defines the component's styling. LWC uses <code>Shadow DOM</code> for <code>CSS</code> encapsulation, meaning styles defined in a component's <code>CSS</code> file are scoped to that component and don't leak out or interfere with other components' styles.</p>
    <pre><code class="language-css">/* helloWorld.css */
.container {
    padding: 20px;
    border: 1px solid #ccc;
    border-radius: 8px;
    background-color: #f9f9f9;
    text-align: center;
}

h1 {
    color: #0070d2;
    font-size: 2em;
}

button {
    background-color: #0070d2;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 1em;
    transition: background-color 0.3s ease;
}

button:hover {
    background-color: #005fb2;
}
</code></pre>
    <p>This encapsulation helps prevent style conflicts in complex applications.</p>
</div>

<div id="content-component-structure" class="topic-content-section">
    <h2>3. LWC Component Structure</h2>
    <p>Every Lightning Web Component resides in a folder with the same name as the component. This folder contains the component's HTML, JavaScript, and metadata files. Optionally, it can also contain a CSS file.</p>
    <h3>Standard Folder Structure:</h3>
    <pre><code class="language-plaintext">force-app/main/default/lwc/
└── myComponentName/
    ├── myComponentName.html
    ├── myComponentName.js
    ├── myComponentName.css (Optional)
    └── myComponentName.js-meta.xml
</code></pre>
    <ul>
        <li><code>myComponentName.html</code> (Template): Defines the component's user interface.</li>
        <li><code>myComponentName.js</code> (JavaScript): Contains the component's logic, properties, and event handlers.</li>
        <li><code>myComponentName.css</code> (CSS - Optional): Contains the component's styles. Styles are scoped to the component due to <code>Shadow DOM</code>.</li>
        <li><code>myComponentName.js-meta.xml</code> (Metadata): This crucial file defines the component's metadata, such as its API version, whether it's exposed to Lightning App Builder or Experience Builder, and which objects it can be used on.</li>
    </ul>

    <h3>Example <code>myComponentName.js-meta.xml</code>:</h3>
    <pre><code class="language-xml">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;LightningComponentBundle xmlns="http://soap.sforce.com/2006/04/metadata"&gt;
    &lt;apiVersion&gt;58.0&lt;/apiVersion&gt;
    &lt;isExposed&gt;true&lt;/isExposed&gt;
    &lt;targets&gt;
        &lt;target&gt;lightning__AppPage&lt;/target&gt;
        &lt;target&gt;lightning__RecordPage&lt;/target&gt;
        &lt;target&gt;lightning__HomePage&lt;/target&gt;
        &lt;target&gt;lightningCommunity__Page&lt;/target&gt;
        &lt;target&gt;lightningCommunity__Default&lt;/target&gt;
    &lt;/targets&gt;
    &lt;targetConfigs&gt;
        &lt;targetConfig targets="lightning__RecordPage"&gt;
            &lt;objects&gt;
                &lt;object&gt;Account&lt;/object&gt;
                &lt;object&gt;Contact&lt;/object&gt;
            &lt;/objects&gt;
        &lt;/targetConfig&gt;
    &lt;/targetConfigs&gt;
&lt;/LightningComponentBundle&gt;
</code></pre>
    <ul>
        <li><code>apiVersion</code>: Specifies the API version for the component.</li>
        <li><code>isExposed</code>: Set to <code>true</code> to make the component available in Lightning App Builder, Experience Builder, or as a tab.</li>
        <li><code>targets</code>: Defines where the component can be used (e.g., App Page, Record Page, Home Page, Community Page).</li>
        <li><code>targetConfigs</code>: Provides specific configurations for different targets, such as restricting usage to certain sObjects on a record page.</li>
    </ul>
    <p>Properly configuring the <code>js-meta.xml</code> file is essential for deploying and using your LWC components within Salesforce.</p>
</div>

<div id="content-data-flow-decorators" class="topic-content-section">
    <h2>4. Data Flow & Decorators (<code>@api</code>, <code>@track</code>, <code>@wire</code>)</h2>
    <p>LWC uses decorators to enable reactivity and public properties in JavaScript classes. These decorators are imported from the <code>lwc</code> module and play a crucial role in how data flows within and between components.</p>
    <h3>a. <code>@api</code> Decorator (Public Properties):</h3>
    <ul>
        <li><strong>Purpose:</strong> Exposes a property as public. Parent components can set the value of a public property on a child component. Changes to <code>@api</code> properties are reactive.</li>
        <li><strong>Use Cases:</strong> Passing data down from a parent component to a child component.</li>
        <li><strong>Syntax:</strong>
            <pre><code class="language-javascript">import { LightningElement, api } from 'lwc';

export default class ChildComponent extends LightningElement {
    @api recordId; // Public property to receive a record ID
    @api message = 'Default Message'; // Public property with a default value
}
</code></pre>
            <p>In a parent component's HTML:</p>
            <pre><code class="language-html">&lt;c-child-component record-id="001..." message="Hello from Parent"&gt;&lt;/c-child-component&gt;
</code></pre>
        </li>
    </ul>

    <h3>b. <code>@track</code> Decorator (Reactive Private Properties - Legacy):</h3>
    <ul>
        <li><strong>Purpose:</strong> Makes a private property reactive. When the value of a <code>@track</code> property changes, the component's template re-renders.
        <li><strong>Important Note:</strong> As of <code>Winter '20</code>, all fields in a Lightning Web Component are reactive by default. You only need to use <code>@track</code> if the field holds an object or an array and you want the component to re-render when the *properties of the object or elements of the array* change, not just when the object/array reference itself changes. For primitive values, <code>@track</code> is no longer necessary.</li>
        <li><strong>Syntax (for objects/arrays):</strong>
            <pre><code class="language-javascript">import { LightningElement, track } from 'lwc';

export default class MyComponent extends LightningElement {
    @track myObject = { name: 'Initial', value: 0 };

    updateObject() {
        // To make changes reactive for objects, you must create a new object
        // or reassign the property, or use @track if modifying properties directly.
        // Best practice: Reassign for clarity.
        this.myObject = { ...this.myObject, value: this.myObject.value + 1 };
    }
}
</code></pre>
        </li>
    </ul>

    <h3>c. <code>@wire</code> Decorator (Reactive Data Service):</h3>
    <ul>
        <li><strong>Purpose:</strong> Used to read Salesforce data. It invokes an Apex method or a <code>UI API</code> wire adapter and provisions the data to a property or function. The <code>@wire</code> service is reactive, meaning if the underlying data changes in Salesforce, the component automatically re-renders with the new data.</li>
        <li><strong>Use Cases:</strong> Fetching records, getting picklist values, querying Apex methods.</li>
        <li><strong>Syntax:</strong>
            <pre><code class="language-javascript">import { LightningElement, wire } from 'lwc';
import getAccounts from '@salesforce/apex/AccountController.getAccounts'; // Import Apex method

export default class AccountList extends LightningElement {
    @wire(getAccounts)
    accounts; // Data is provisioned to this property

    // Or to a function for more control
    // @wire(getAccounts)
    // wiredAccounts({ error, data }) {
    //     if (data) {
    //         this.accounts = data;
    //         this.error = undefined;
    //     } else if (error) {
    //         this.error = error;
    //         this.accounts = undefined;
    //     }
    // }
}
</code></pre>
            <p>The <code>accounts</code> property will receive an object with <code>data</code> and <code>error</code> properties. The component automatically re-renders when <code>accounts.data</code> or <code>accounts.error</code> changes.</p>
        </li>
    </ul>
</div>

<div id="content-event-communication" class="topic-content-section">
    <h2>5. Event Communication</h2>
    <p>Components in LWC communicate primarily through events. Understanding event flow is crucial for building interactive applications where components need to interact with each other.</p>
    <h3>a. Child-to-Parent Communication (Custom Events):</h3>
    <p>Children components dispatch custom events, and parent components listen for them. This is the recommended way for a child to notify its parent of an action or data change.</p>
    <ul>
        <li><strong>Dispatching an Event (Child Component):</strong>
            <pre><code class="language-javascript">// childComponent.js
import { LightningElement } from 'lwc';

export default class ChildComponent extends LightningElement {
    handleClick() {
        const myCustomEvent = new CustomEvent('childclick', {
            detail: { message: 'Hello from child!' }, // Data to pass
            bubbles: true, // Allows event to bubble up the DOM
            composed: true // Allows event to cross Shadow DOM boundaries
        });
        this.dispatchEvent(myCustomEvent);
    }
}
</code></pre>
            <pre><code class="language-html">&lt;!-- childComponent.html --&gt;
&lt;template&gt;
    &lt;button onclick={handleClick}&gt;Click Me (Child)&lt;/button&gt;
&lt;/template&gt;
</code></pre>
        </li>
        <li><strong>Listening for an Event (Parent Component):</strong>
            <p>In the parent's HTML, use <code>on</code> + event name (lowercase, no "on" prefix on the event name itself).</p>
            <pre><code class="language-html">&lt;!-- parentComponent.html --&gt;
&lt;template&gt;
    &lt;h1&gt;Parent Component&lt;/h1&gt;
    &lt;p&gt;Message from child: {childMessage}&lt;/p&gt;
    &lt;c-child-component onchildclick={handleChildClick}&gt;&lt;/c-child-component&gt;
&lt;/template&gt;
</code></pre>
            <pre><code class="language-javascript">// parentComponent.js
import { LightningElement, track } from 'lwc';

export default class ParentComponent extends LightningElement {
    @track childMessage = '';

    handleChildClick(event) {
        this.childMessage = event.detail.message;
        console.log('Event received from child:', event.detail.message);
    }
}
</code></pre>
        </li>
    </ul>

    <h3>b. Parent-to-Child Communication (Public Properties):</h3>
    <p>As discussed with <code>@api</code>, parents pass data down to children using public properties.</p>

    <h3>c. Communication Between Unrelated Components (Lightning Message Service - LMS):</h3>
    <p>For components that are not in a direct parent-child relationship (e.g., components on different parts of a Lightning page, or across different tabs), <code>Lightning Message Service (LMS)</code> is the recommended solution. It uses a publish-subscribe model.</p>
    <ul>
        <li>Define a <code>Message Channel</code> (<code>XML</code> file in <code>messageChannels</code> folder).</li>
        <li>Publish messages from one component.</li>
        <li>Subscribe to messages in another component.</li>
    </ul>
    <pre><code class="language-javascript">// publisherComponent.js
import { LightningElement, wire } from 'lwc';
import { publish, MessageContext } from 'lightning/messageService';
import SAMPLE_MESSAGE_CHANNEL from '@salesforce/messageChannel/SampleMessageChannel__c'; // Import message channel

export default class PublisherComponent extends LightningElement {
    @wire(MessageContext)
    messageContext;

    publishMessage() {
        const payload = { recordId: '001ABC', message: 'Data updated!' };
        publish(this.messageContext, SAMPLE_MESSAGE_CHANNEL, payload);
    }
}
</code></pre>
    <pre><code class="language-javascript">// subscriberComponent.js
import { LightningElement, wire } from 'lwc';
import { subscribe, unsubscribe, MessageContext } from 'lightning/messageService';
import SAMPLE_MESSAGE_CHANNEL from '@salesforce/messageChannel/SampleMessageChannel__c';

export default class SubscriberComponent extends LightningElement {
    subscription = null;
    receivedMessage = '';

    @wire(MessageContext)
    messageContext;

    connectedCallback() {
        this.subscribeToMessageChannel();
    }

    subscribeToMessageChannel() {
        if (!this.subscription) {
            this.subscription = subscribe(
                this.messageContext,
                SAMPLE_MESSAGE_CHANNEL,
                (message) => this.handleMessage(message)
            );
        }
    }

    handleMessage(message) {
        this.receivedMessage = message.message + ' for ' + message.recordId;
    }

    disconnectedCallback() {
        this.unsubscribeFromMessageChannel();
    }

    unsubscribeFromMessageChannel() {
        unsubscribe(this.subscription);
        this.subscription = null;
    }
}
</code></pre>
</div>

<div id="content-lifecycle-hooks" class="topic-content-section">
    <h2>6. LWC Lifecycle Hooks</h2>
    <p>LWC components have a well-defined lifecycle, and you can tap into specific phases using lifecycle hooks. These methods allow you to execute code at particular moments, such as when a component is inserted into the <code>DOM</code>, when it re-renders, or when it's removed.</p>
    <p>All lifecycle hooks are methods in the component's JavaScript class.</p>
    <ul>
        <li><strong><code>constructor()</code>:</strong>
            <ul>
                <li><strong>Purpose:</strong> Called when the component is created.</li>
                <li><strong>Important:</strong> Always call <code>super()</code> first. Do not access <code>@api</code> properties or the component's <code>host</code> element (<code>this.template</code>) here, as they are not yet initialized.</li>
                <li><strong>Use Cases:</strong> Initializing private properties.</li>
            </ul>
        </li>
        <li><strong><code>connectedCallback()</code>:</strong>
            <ul>
                <li><strong>Purpose:</strong> Called when the component is inserted into the <code>DOM</code>.</li>
                <li><strong>Use Cases:</strong> Fetching initial data (if not using <code>@wire</code>), setting up event listeners, accessing <code>@api</code> properties.</li>
                <li><strong>Important:</strong> If the component is removed and reinserted, this hook fires again.</li>
            </ul>
        </li>
        <li><strong><code>renderedCallback()</code>:</strong>
            <ul>
                <li><strong>Purpose:</strong> Called after every render of the component. This includes the initial render and subsequent re-renders due to reactive property changes.</li>
                <li><strong>Important:</strong> Be cautious with logic here to avoid infinite loops. Do not update reactive properties directly in <code>renderedCallback</code> without a condition, as it will trigger another re-render.</li>
                <li><strong>Use Cases:</strong> Performing <code>DOM</code> manipulations after rendering, integrating with third-party libraries that need the <code>DOM</code> to be ready.</li>
            </ul>
        </li>
        <li><strong><code>disconnectedCallback()</code>:</strong>
            <ul>
                <li><strong>Purpose:</strong> Called when the component is removed from the <code>DOM</code>.</li>
                <li><strong>Use Cases:</strong> Cleaning up event listeners, unsubscribing from external services (like <code>LMS</code>) to prevent memory leaks.</li>
            </ul>
        </li>
        <li><strong><code>errorCallback(error, stack)</code>:</strong>
            <ul>
                <li><strong>Purpose:</strong> Called when an error occurs in any descendant component in the component's subtree. Acts like a JavaScript error boundary.</li>
                <li><strong>Use Cases:</strong> Catching and logging errors, displaying a fallback <code>UI</code> when an error occurs in a child component.</li>
            </ul>
        </li>
    </ul>
    <h3>Example:</h3>
    <pre><code class="language-javascript">import { LightningElement, api } from 'lwc';

export default class LifecycleDemo extends LightningElement {
    @api recordId;
    
    constructor() {
        super();
        console.log('1. Constructor called');
        // Do NOT access this.recordId or this.template here
    }

    connectedCallback() {
        console.log('2. Connected Callback called. Record ID:', this.recordId);
        // Fetch data or set up listeners here
    }

    renderedCallback() {
        console.log('3. Rendered Callback called.');
        // Be careful: Avoid infinite loops.
        // Example: if (!this.hasRendered) { this.hasRendered = true; console.log('First render'); }
    }

    disconnectedCallback() {
        console.log('4. Disconnected Callback called.');
        // Clean up resources here
    }

    errorCallback(error, stack) {
        console.error('5. Error Callback called:', error);
        console.error('Stack:', stack);
        // Display an error message to the user or log it
    }
}
</code></pre>
</div>

<div id="content-working-with-apex" class="topic-content-section">
    <h2>7. Working with Apex in LWC</h2>
    <p>Lightning Web Components can interact with Salesforce data and logic stored in Apex classes. This integration allows you to perform complex database operations, execute business logic, and make callouts that are not possible directly in client-side LWC.</p>
    <h3>a. Calling Apex Imperatively:</h3>
    <p>Use imperative Apex calls when you need to control when the Apex method executes (e.g., on a button click, after user input). This provides more flexibility than <code>@wire</code> for fetching data.</p>
    <ul>
        <li><strong>Import Apex Method:</strong>
            <pre><code class="language-javascript">import getAccounts from '@salesforce/apex/AccountController.getAccounts';
</code></pre>
            Where <code>AccountController</code> is your Apex class and <code>getAccounts</code> is the method.
        </li>
        <li><strong>Apex Method Definition:</strong> The Apex method must be <code>public static</code> and annotated with <code>@AuraEnabled</code>. If it modifies data, it should also be <code>@AuraEnabled(cacheable=true)</code> for read-only methods to allow caching and improve performance.
            <pre><code class="language-apex">public with sharing class AccountController {
    @AuraEnabled(cacheable=true) // cacheable=true for read-only methods
    public static List&lt;Account&gt; getAccounts() {
        return [SELECT Id, Name, Industry FROM Account LIMIT 10];
    }

    @AuraEnabled
    public static String createAccount(String accountName) {
        Account newAcc = new Account(Name = accountName);
        insert newAcc;
        return newAcc.Id;
    }
}
</code></pre>
        </li>
        <li><strong>Calling from LWC:</strong>
            <pre><code class="language-javascript">import { LightningElement } from 'lwc';
import getAccounts from '@salesforce/apex/AccountController.getAccounts';
import createAccount from '@salesforce/apex/AccountController.createAccount';

export default class ApexImperativeDemo extends LightningElement {
    accounts;
    error;

    handleLoadAccounts() {
        getAccounts()
            .then(result => {
                this.accounts = result;
                this.error = undefined;
            })
            .catch(error => {
                this.error = error;
                this.accounts = undefined;
            });
    }

    handleCreateAccount() {
        createAccount({ accountName: 'New Imperative Account' }) // Pass parameters as an object
            .then(result => {
                console.log('Account created with ID:', result);
                this.handleLoadAccounts(); // Refresh the list
            })
            .catch(error => {
                this.error = error;
                console.error('Error creating account:', error);
            });
    }
}
</code></pre>
        </li>
    </ul>

    <h3>b. Calling Apex with <code>@wire</code> (Reactive):</h3>
    <p>As discussed in the "Data Flow & Decorators" section, <code>@wire</code> is used for reactive data provisioning from Apex. It automatically refreshes data when reactive parameters change or when the underlying Salesforce data is updated.</p>
    <ul>
        <li><strong>Syntax:</strong>
            <pre><code class="language-javascript">import { LightningElement, wire } from 'lwc';
import getAccountDetails from '@salesforce/apex/AccountController.getAccountDetails';

export default class AccountDetailsWire extends LightningElement {
    @api recordId; // This is a reactive parameter for the wire method

    @wire(getAccountDetails, { accountId: '$recordId' }) // '$' prefix makes it reactive
    wiredAccount({ error, data }) {
        if (data) {
            this.account = data;
            this.error = undefined;
        } else if (error) {
            this.error = error;
            this.account = undefined;
        }
    }
}
</code></pre>
        </li>
    </ul>
    <p>Choose between imperative and <code>@wire</code> based on whether you need immediate, controlled execution (imperative) or reactive, automatic data updates (<code>@wire</code>).</p>
</div>

<div id="content-best-practices" class="topic-content-section">
    <h2>8. LWC Best Practices</h2>
    <p>Adhering to best practices ensures your Lightning Web Components are performant, maintainable, secure, and reusable.</p>
    <h3>a. Component Granularity:</h3>
    <ul>
        <li><strong>Small, Focused Components:</strong> Design components to do one thing well. Break down complex <code>UIs</code> into smaller, reusable child components.</li>
        <li><strong>Container vs. Presentational:</strong> Separate concerns. Container components handle data fetching and logic, while presentational components focus solely on rendering <code>UI</code> based on input properties.</li>
    </ul>
    <h3>b. Data Flow & Reactivity:</h3>
    <ul>
        <li><strong>Unidirectional Data Flow:</strong> Data flows down from parent to child via <code>@api</code> properties. Events flow up from child to parent via custom events.</li>
        <li><strong>Minimize <code>@track</code>:</strong> Only use <code>@track</code> for objects or arrays if you need reactivity on their internal property changes. For primitive values, it's automatic.</li>
        <li><strong>Use <code>@wire</code> for Data Fetching:</strong> Prefer <code>@wire</code> for read-only data from Salesforce/Apex due to its reactivity and caching benefits. Use imperative Apex for <code>DML</code> or when explicit control over execution is needed.</li>
    </ul>
    <h3>c. Performance:</h3>
    <ul>
        <li><strong>Lazy Loading:</strong> Load data or components only when needed.</li>
        <li><strong>Minimize <code>DOM</code> Manipulation:</strong> Let the framework handle <code>DOM</code> updates. Avoid direct <code>document.querySelector</code> or <code>this.template.querySelector</code> unless absolutely necessary, especially in <code>renderedCallback</code> without guards.</li>
        <li><strong>Optimize Apex Calls:</strong> Ensure your Apex methods are bulkified and selective to avoid governor limits.</li>
    </ul>
    <h3>d. Security:</h3>
    <ul>
        <li><strong>Respect <code>FLS</code> & <code>CRUD</code>:</strong> LWC, by default, respects <code>Field-Level Security (FLS)</code> and <code>Create</code>, <code>Read</code>, <code>Update</code>, <code>Delete (CRUD)</code> permissions for <code>UI API</code> calls. For Apex calls, use <code>with sharing</code> or <code>without sharing</code> appropriately, and always check <code>FLS</code> and <code>CRUD</code> permissions manually in Apex if dealing with sensitive data or complex queries.</li>
        <li><strong>Sanitize User Input:</strong> Always sanitize any user input before using it in queries or <code>DML</code> operations to prevent injection attacks.</li>
    </ul>
    <h3>e. Reusability & Maintainability:</h3>
    <ul>
        <li><strong>Clear Naming Conventions:</strong> Use consistent and descriptive names for components, properties, methods, and events.</li>
        <li><strong>Comments:</strong> Document complex logic, especially for non-obvious parts.</li>
        <li><strong>Modular <code>CSS</code>:</strong> Leverage <code>Shadow DOM</code> for encapsulation. Avoid global <code>CSS</code> rules that could unintentionally affect other components.</li>
        <li><strong>Use Lightning Base Components:</strong> Utilize standard <code>lightning-</code> components (e.g., <code>lightning-button</code>, <code>lightning-input</code>, <code>lightning-datatable</code>) whenever possible. They are performant, accessible, and adhere to <code>Salesforce Lightning Design System (SLDS)</code>.</li>
    </ul>
    <h3>f. Testing:</h3>
    <ul>
        <li><strong>Write Unit Tests:</strong> Use <code>Jest</code> for client-side LWC unit testing to verify component behavior in isolation.</li>
        <li><strong>Test Apex Integration:</strong> Ensure your Apex methods called by LWC are covered by Apex unit tests.</li>
    </ul>
</div>

<div id="content-conclusion" class="topic-content-section">
    <h2>9. Conclusion & Next Steps</h2>
    <p>Lightning Web Components provide a powerful, modern, and efficient framework for building rich user interfaces on the Salesforce platform. By embracing web standards and offering robust features for data binding, event communication, and Apex integration, LWC empowers developers to create highly performant and maintainable applications.</p>
    <h3>Key Takeaways:</h3>
    <ul>
        <li><strong>Web Standards First:</strong> LWC is built on modern web standards, making it approachable for web developers.</li>
        <li><strong>Component-Based:</strong> Focus on building small, reusable, and encapsulated components.</li>
        <li><strong>Decorators are Key:</strong> Understand <code>@api</code> for public properties, <code>@track</code> for reactive objects/arrays, and <code>@wire</code> for reactive data provisioning.</li>
        <li><strong>Event-Driven Communication:</strong> Use custom events for child-to-parent and <code>LMS</code> for unrelated component communication.</li>
        <li><strong>Lifecycle Awareness:</strong> Leverage lifecycle hooks to execute code at specific points in a component's life.</li>
        <li><strong>Apex Integration:</strong> Seamlessly connect to Apex for server-side logic and data operations.</li>
        <li><strong>Best Practices:</strong> Prioritize performance, security, reusability, and thorough testing.</li>
    </ul>
    <p>Mastering LWC is essential for any Salesforce developer looking to build modern, engaging, and scalable user experiences. Continue exploring the official <code>Salesforce LWC Developer Guide</code> and <code>Trailhead</code> modules for deeper dives into advanced topics and real-world scenarios.</p>
</div>